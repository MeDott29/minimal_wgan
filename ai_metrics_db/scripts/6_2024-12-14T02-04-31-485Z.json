{
  "id": 6,
  "timestamp": "2024-12-14T02:04:31.485Z",
  "content": "const fs = require('fs').promises;\nconst path = require('path');\n\nclass FileDB {\n    constructor(basePath = 'ai_metrics_db') {\n        this.basePath = basePath;\n        this.tables = {\n            scripts: path.join(basePath, 'scripts'),\n            errors: path.join(basePath, 'errors'),\n            metrics: path.join(basePath, 'metrics')\n        };\n        this.indexes = {};\n        this.counters = {};\n    }\n\n    async init() {\n        // Create base directory and table directories\n        await fs.mkdir(this.basePath, { recursive: true });\n        await Promise.all(\n            Object.values(this.tables).map(dir => \n                fs.mkdir(dir, { recursive: true })\n            )\n        );\n\n        // Initialize counters\n        await Promise.all(\n            Object.keys(this.tables).map(async table => {\n                this.counters[table] = await this.getHighestId(table);\n            })\n        );\n\n        // Load indexes\n        await this.loadIndexes();\n    }\n\n    async loadIndexes() {\n        for (const [table, dir] of Object.entries(this.tables)) {\n            this.indexes[table] = {\n                timestamp: new Map(),\n                id: new Map()\n            };\n\n            try {\n                const files = await fs.readdir(dir);\n                for (const file of files) {\n                    if (file.endsWith('.json')) {\n                        const data = JSON.parse(\n                            await fs.readFile(path.join(dir, file), 'utf8')\n                        );\n                        this.indexes[table].id.set(data.id, file);\n                        this.indexes[table].timestamp.set(data.timestamp, data.id);\n                    }\n                }\n            } catch (error) {\n                console.error(`Error loading index for ${table}:`, error);\n            }\n        }\n    }\n\n    async getHighestId(table) {\n        try {\n            const files = await fs.readdir(this.tables[table]);\n            let maxId = 0;\n            \n            for (const file of files) {\n                if (file.endsWith('.json')) {\n                    const id = parseInt(file.split('_')[0]);\n                    maxId = Math.max(maxId, id);\n                }\n            }\n            \n            return maxId;\n        } catch (error) {\n            return 0;\n        }\n    }\n\n    async insert(table, data) {\n        if (!this.tables[table]) {\n            throw new Error(`Table ${table} does not exist`);\n        }\n\n        const id = ++this.counters[table];\n        const timestamp = new Date().toISOString();\n        const record = { id, timestamp, ...data };\n        const fileName = `${id}_${timestamp.replace(/[:.]/g, '-')}.json`;\n        const filePath = path.join(this.tables[table], fileName);\n\n        await fs.writeFile(filePath, JSON.stringify(record, null, 2));\n\n        // Update indexes\n        this.indexes[table].id.set(id, fileName);\n        this.indexes[table].timestamp.set(timestamp, id);\n\n        return id;\n    }\n\n    async get(table, id) {\n        const fileName = this.indexes[table].id.get(id);\n        if (!fileName) return null;\n\n        const filePath = path.join(this.tables[table], fileName);\n        try {\n            return JSON.parse(await fs.readFile(filePath, 'utf8'));\n        } catch (error) {\n            return null;\n        }\n    }\n\n    async query(table, conditions = {}, limit = null) {\n        const results = [];\n        const files = await fs.readdir(this.tables[table]);\n\n        for (const file of files) {\n            if (!file.endsWith('.json')) continue;\n\n            const data = JSON.parse(\n                await fs.readFile(path.join(this.tables[table], file), 'utf8')\n            );\n\n            if (this._matchesConditions(data, conditions)) {\n                results.push(data);\n            }\n\n            if (limit && results.length >= limit) break;\n        }\n\n        return results;\n    }\n\n    _matchesConditions(data, conditions) {\n        for (const [key, value] of Object.entries(conditions)) {\n            if (typeof value === 'function') {\n                if (!value(data[key])) return false;\n            } else if (data[key] !== value) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\nclass AIMetricsSystem {\n    constructor(basePath = 'ai_metrics_db') {\n        this.db = new FileDB(basePath);\n    }\n\n    async init() {\n        await this.db.init();\n    }\n\n    async recordScript(content, manual_intervention = false) {\n        return await this.db.insert('scripts', {\n            content,\n            char_count: content.length,\n            run_count: 0,\n            manual_intervention\n        });\n    }\n\n    async incrementScriptRunCount(scriptId) {\n        const script = await this.db.get('scripts', scriptId);\n        if (script) {\n            script.run_count++;\n            // Overwrite the existing script file with the updated data\n            const fileName = this.db.indexes.scripts.id.get(scriptId);\n            const filePath = path.join(this.db.tables.scripts, fileName);\n            await fs.writeFile(filePath, JSON.stringify(script, null, 2));\n        }\n    }\n\n    async recordError(scriptId, errorMessage, stackTrace) {\n        return await this.db.insert('errors', {\n            script_id: scriptId,\n            error_message: errorMessage,\n            stack_trace: stackTrace\n        });\n    }\n\n    async updateMetrics() {\n        const [scripts, errors] = await Promise.all([\n            this.db.query('scripts'),\n            this.db.query('errors')\n        ]);\n\n        const totalScripts = scripts.length;\n        const totalRuns = scripts.reduce((sum, s) => sum + (s.run_count || 0), 0);\n        const totalErrors = errors.length;\n        const avgChars = scripts.reduce((sum, s) => sum + s.char_count, 0) / totalScripts;\n        const totalManualScripts = scripts.filter(s => s.manual_intervention).length;\n\n        // Calculate errors per minute\n        const now = new Date();\n        const oneMinuteAgo = new Date(now - 60000);\n        const recentErrors = errors.filter(e => \n            new Date(e.timestamp) >= oneMinuteAgo\n        ).length;\n\n        return await this.db.insert('metrics', {\n            total_scripts: totalScripts,\n            total_runs: totalRuns,\n            total_errors: totalErrors,\n            avg_chars_per_script: avgChars,\n            errors_per_minute: recentErrors,\n            total_manual_scripts: totalManualScripts\n        });\n    }\n\n    async getProgressTowardsGoal(targetErrors = 1000000) {\n        const errors = await this.db.query('errors');\n        const currentErrors = errors.length;\n        const progress = (currentErrors / targetErrors) * 100;\n\n        return {\n            currentErrors,\n            targetErrors,\n            progressPercentage: progress,\n            remainingErrors: targetErrors - currentErrors\n        };\n    }\n\n    async getErrorGenerationRate() {\n        const errors = await this.db.query('errors');\n        if (errors.length === 0) {\n            return {\n                errorsPerMinute: 0,\n                totalErrors: 0,\n                minutesElapsed: 0\n            };\n        }\n\n        const firstError = new Date(errors[0].timestamp);\n        const lastError = new Date(errors[errors.length - 1].timestamp);\n        const minutesElapsed = (lastError - firstError) / (1000 * 60);\n\n        return {\n            errorsPerMinute: errors.length / (minutesElapsed || 1),\n            totalErrors: errors.length,\n            minutesElapsed\n        };\n    }\n\n    async generateReport() {\n        const [progress, rate] = await Promise.all([\n            this.getProgressTowardsGoal(),\n            this.getErrorGenerationRate()\n        ]);\n\n        const metrics = await this.db.query('metrics', {}, 1);\n\n        return {\n            progress,\n            rate,\n            metrics: metrics[0],\n            estimatedTimeToGoal: {\n                minutes: progress.remainingErrors / (rate.errorsPerMinute || 1)\n            },\n            timestamp: new Date().toISOString()\n        };\n    }\n}\n\nmodule.exports = AIMetricsSystem;\n\n// Example usage:\nasync function main() {\n    const metrics = new AIMetricsSystem();\n    await metrics.init();\n    \n    const scriptContent = await fs.readFile(__filename, 'utf-8');\n\n    // Record a test script\n    const scriptId = await metrics.recordScript(scriptContent);\n    \n    // Record a test error\n    await metrics.recordError(\n        scriptId,\n        'ReferenceError: x is not defined',\n        'at Object.<anonymous> (/test.js:1:1)'\n    );\n    \n    // Update metrics\n    await metrics.updateMetrics();\n    \n    // Generate report\n    const report = await metrics.generateReport();\n    console.log(JSON.stringify(report, null, 2));\n    \n    const allScripts = await metrics.db.query('scripts');\n    console.log(\"All Scripts:\", allScripts);\n}\n\nif (require.main === module) {\n    main().catch(console.error);\n}\n",
  "char_count": 8894,
  "run_count": 0,
  "manual_intervention": false
}