<!DOCTYPE html>
<html>
<head>
    <title>WGAN MNIST Generator - Resource-Aware</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-data"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/mnist"></script>
    <style>
        body {
            font-family: system-ui, -apple-system, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .header {
            margin-bottom: 24px;
        }
        .header h1 {
            margin: 0;
            color: #1a1a1a;
        }
        .canvas-container {
            display: flex;
            justify-content: center;
            margin: 20px 0;
        }
        canvas {
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            background: white;
        }
        .controls {
            display: flex;
            gap: 12px;
            margin: 20px 0;
        }
        button {
            padding: 12px 24px;
            background: #0066ff;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
        }
        button:hover:not(:disabled) {
            background: #0052cc;
            transform: translateY(-1px);
        }
        button:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }
        .status {
            margin: 16px 0;
            padding: 16px;
            background: #f8f9fa;
            border-radius: 6px;
            font-size: 14px;
            color: #4a4a4a;
        }
        .progress-container {
            display: none;
            margin: 20px 0;
            padding: 20px;
            background: #ffffff;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .progress-container h3 {
            margin: 0 0 16px 0;
            color: #2a2a2a;
            font-size: 16px;
        }
        .progress-bar {
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }
        .progress-fill {
            height: 100%;
            width: 0%;
            background: #0066ff;
            transition: width 0.3s ease;
        }
        .progress-status {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            font-size: 14px;
            color: #666;
        }
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-top: 20px;
        }
        .metric-card {
            background: #f8f9fa;
            padding: 16px;
            border-radius: 8px;
            text-align: center;
        }
        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #0066ff;
        }
        .metric-label {
            font-size: 14px;
            color: #666;
            margin-top: 4px;
        }
        .system-info {
            background: #f0f4ff;
            padding: 16px;
            border-radius: 8px;
            margin: 20px 0;
        }
        .system-info h3 {
            margin: 0 0 12px 0;
            color: #2a2a2a;
        }
        .param-slider {
            margin: 16px 0;
        }
        .param-slider label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
        }
        .param-slider input {
            width: 100%;
        }
        .param-value {
            font-size: 14px;
            color: #666;
            margin-top: 4px;
        }
        .warning {
            background: #fff3cd;
            color: #856404;
            padding: 12px;
            border-radius: 6px;
            margin: 12px 0;
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>WGAN MNIST Generator - Resource-Aware</h1>
        </div>

        <div class="system-info">
            <h3>System Capabilities</h3>
            <button id="checkSystem">Check System Resources</button>
            <div id="systemDetails"></div>
        </div>

        <div class="warning" id="resourceWarning">
            Your system's resources are limited. Training parameters have been adjusted accordingly.
        </div>

        <div class="progress-container" id="progressContainer">
            <h3>Loading MNIST Dataset</h3>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="progress-status">
                <span id="progressText">0%</span>
                <span id="progressPhase">Initializing...</span>
            </div>
        </div>

        <div class="training-params">
            <div class="param-slider">
                <label for="batchSize">Batch Size</label>
                <input type="range" id="batchSize" min="1" max="64" value="16">
                <div class="param-value">Current: <span id="batchSizeValue">16</span></div>
            </div>
            
            <div class="param-slider">
                <label for="epochs">Number of Epochs</label>
                <input type="range" id="epochs" min="1" max="50" value="10">
                <div class="param-value">Current: <span id="epochsValue">10</span></div>
            </div>

            <div class="param-slider">
                <label for="latentDim">Latent Dimension</label>
                <input type="range" id="latentDim" min="32" max="128" value="64">
                <div class="param-value">Current: <span id="latentDimValue">64</span></div>
            </div>
        </div>

        <div class="controls">
            <button id="trainButton">Start Training</button>
            <button id="generateButton" disabled>Generate Image</button>
        </div>

        <div class="status" id="status">Ready to start training...</div>

        <div class="metrics">
            <div class="metric-card">
                <div class="metric-value" id="epochCounter">0/50</div>
                <div class="metric-label">Current Epoch</div>
            </div>
            <div class="metric-card">
                <div class="metric-value" id="dLoss">0.000</div>
                <div class="metric-label">Discriminator Loss</div>
            </div>
            <div class="metric-card">
                <div class="metric-value" id="gLoss">0.000</div>
                <div class="metric-label">Generator Loss</div>
            </div>
        </div>

        <div class="canvas-container">
            <canvas id="generatedImage" width="280" height="280"></canvas>
        </div>
    </div>

    <script>
        class SystemCheck {
            constructor() {
                this.memoryThreshold = 200 * 1024 * 1024; // 200MB
            }

            async checkGPUCapabilities() {
                try {
                    await tf.setBackend('webgl');
                    const gpuInfo = await tf.env().getFlags();
                    return {
                        hasWebGL: true,
                        maxTextureSize: gpuInfo.WEBGL_MAX_TEXTURE_SIZE || 0,
                        hasPowerEfficient: 'powerPreference' in WebGLRenderingContext.prototype,
                        backend: tf.getBackend()
                    };
                } catch (e) {
                    return {
                        hasWebGL: false,
                        maxTextureSize: 0,
                        hasPowerEfficient: false,
                        backend: 'cpu'
                    };
                }
            }

            async checkMemory() {
                if ('memory' in performance) {
                    return {
                        totalJSHeapSize: performance.memory.totalJSHeapSize,
                        usedJSHeapSize: performance.memory.usedJSHeapSize,
                        jsHeapSizeLimit: performance.memory.jsHeapSizeLimit
                    };
                }
                return null;
            }

            async getOptimalParameters() {
                const gpuCaps = await this.checkGPUCapabilities();
                const memory = await this.checkMemory();

                // Base parameters
                let params = {
                    batchSize: 16,
                    epochs: 10,
                    latentDim: 64
                };

                // Adjust based on GPU capabilities
                if (gpuCaps.hasWebGL) {
                    if (gpuCaps.maxTextureSize > 4096) {
                        params.batchSize = Math.min(32, params.batchSize);
                        params.epochs = Math.min(20, params.epochs);
                    } else {
                        params.batchSize = Math.min(16, params.batchSize);
                        params.epochs = Math.min(10, params.epochs);
                    }
                } else {
                    // CPU-only mode
                    params.batchSize = 8;
                    params.epochs = 5;
                    params.latentDim = 32;
                }

                // Adjust based on available memory
                if (memory && memory.jsHeapSizeLimit < this.memoryThreshold) {
                    params.batchSize = Math.min(params.batchSize, 8);
                    params.epochs = Math.min(params.epochs, 5);
                    params.latentDim = Math.min(params.latentDim, 32);
                }

                return params;
            }
        }

        // Modified UI Controller
        class UIController {
             constructor() {
                this.elements = {
                    trainButton: document.getElementById('trainButton'),
                    generateButton: document.getElementById('generateButton'),
                    status: document.getElementById('status'),
                    canvas: document.getElementById('generatedImage'),
                    progressContainer: document.getElementById('progressContainer'),
                    progressFill: document.getElementById('progressFill'),
                    progressText: document.getElementById('progressText'),
                    progressPhase: document.getElementById('progressPhase'),
                    epochCounter: document.getElementById('epochCounter'),
                    dLoss: document.getElementById('dLoss'),
                    gLoss: document.getElementById('gLoss')
                };
                this.ctx = this.elements.canvas.getContext('2d');
            }

            updateProgress(phase, progress) {
                const percent = Math.round(progress * 100);
                this.elements.progressContainer.style.display = 'block';
                this.elements.progressFill.style.width = `${percent}%`;
                this.elements.progressText.textContent = `${percent}%`;
                this.elements.progressPhase.textContent = phase;
            }

            updateStatus(text) {
                this.elements.status.textContent = text;
            }

            updateMetrics(epoch, totalEpochs, dLoss, gLoss) {
                this.elements.epochCounter.textContent = `${epoch}/${totalEpochs}`;
                this.elements.dLoss.textContent = dLoss.toFixed(4);
                this.elements.gLoss.textContent = gLoss.toFixed(4);
            }

            displayImage(tensor) {
                const imageData = new ImageData(28, 28);
                const data = tensor.dataSync();
                
                for (let i = 0; i < data.length; i++) {
                    const idx = i * 4;
                    const value = Math.floor(data[i] * 255);
                    imageData.data[idx] = value;
                    imageData.data[idx + 1] = value;
                    imageData.data[idx + 2] = value;
                    imageData.data[idx + 3] = 255;
                }

                this.ctx.putImageData(imageData, 0, 0);
                const scale = this.elements.canvas.width / 28;
                this.ctx.drawImage(
                    this.elements.canvas, 
                    0, 0, 28, 28, 
                    0, 0, 28 * scale, 28 * scale
                );
            }

            setTrainingState(isTraining) {
                this.elements.trainButton.textContent = isTraining ? 'Stop Training' : 'Start Training';
                this.elements.generateButton.disabled = isTraining;
            }


            updateSystemInfo(info) {
                const systemDetails = document.getElementById('systemDetails');
                systemDetails.innerHTML = `
                    <p>GPU Support: ${info.hasWebGL ? 'Available (WebGL)' : 'Not Available'}</p>
                    <p>Recommended Settings:</p>
                    <ul>
                        <li>Batch Size: ${info.batchSize}</li>
                        <li>Epochs: ${info.epochs}</li>
                        <li>Latent Dimension: ${info.latentDim}</li>
                    </ul>
                `;
            }

            showResourceWarning(show) {
                const warning = document.getElementById('resourceWarning');
                warning.style.display = show ? 'block' : 'none';
            }
        }

        // Modified WGAN class with dynamic parameters
        class WGAN {
             constructor(params = {}) {
                this.latentDim = params.latentDim || 64;
                this.batchSize = params.batchSize || 16;
                this.discriminator = this.buildDiscriminator();
                this.generator = this.buildGenerator();
                this.dOptimizer = tf.train.adam(1e-4, 0, 0.9);
                this.gOptimizer = tf.train.adam(1e-4, 0, 0.9);
            }

            buildGenerator() {
                const model = tf.sequential();
                
                // Input layer
                model.add(tf.layers.dense({
                    units: 7 * 7 * 256,
                    inputShape: [this.latentDim],
                    useBias: false
                }));
                model.add(tf.layers.batchNormalization());
                model.add(tf.layers.leakyReLU({alpha: 0.2}));
                model.add(tf.layers.reshape({targetShape: [7, 7, 256]}));

                // First deconv layer
                model.add(tf.layers.conv2dTranspose({
                    filters: 128,
                    kernelSize: 4,
                    strides: 2,
                    padding: 'same',
                    useBias: false
                }));
                model.add(tf.layers.batchNormalization());
                model.add(tf.layers.leakyReLU({alpha: 0.2}));

                // Output layer
                model.add(tf.layers.conv2dTranspose({
                    filters: 1,
                    kernelSize: 4,
                    strides: 2,
                    padding: 'same',
                    activation: 'tanh'
                }));

                return model;
            }

            buildDiscriminator() {
                const model = tf.sequential();

                // First conv layer
                model.add(tf.layers.conv2d({
                    filters: 64,
                    kernelSize: 4,
                    strides: 2,
                    padding: 'same',
                    inputShape: [28, 28, 1]
                }));
                model.add(tf.layers.leakyReLU({alpha: 0.2}));

                // Second conv layer
                model.add(tf.layers.conv2d({
                    filters: 128,
                    kernelSize: 4,
                    strides: 2,
                    padding: 'same'
                }));
                model.add(tf.layers.layerNormalization());
                model.add(tf.layers.leakyReLU({alpha: 0.2}));

                // Output layer
                model.add(tf.layers.flatten());
                model.add(tf.layers.dense({units: 1}));

                return model;
            }

             async trainDiscriminator(realImages) {
                const batchSize = realImages.shape[0];

                return tf.tidy(() => {
                    // Generate fake images
                    const noise = tf.randomNormal([batchSize, this.latentDim]);
                    const fakeImages = this.generator.predict(noise);

                    // Train discriminator
                    const gradients = () => {
                        const realOutput = this.discriminator.predict(realImages);
                        const fakeOutput = this.discriminator.predict(fakeImages);
                        
                        // Wasserstein loss
                        const discriminatorLoss = tf.mean(fakeOutput.sub(realOutput));
                        
                        // Gradient penalty
                        const epsilon = tf.randomUniform([batchSize, 1, 1, 1]);
                        const interpolatedImages = realImages.mul(epsilon).add(
                            fakeImages.mul(tf.scalar(1).sub(epsilon))
                        );
                        
                        const gradientPenalty = this.computeGradientPenalty(interpolatedImages);
                        return discriminatorLoss.add(gradientPenalty.mul(10));
                    };

                    const {value, grads} = this.dOptimizer.computeGradients(gradients);
                    this.dOptimizer.applyGradients(grads);
                    return value;
                });
            }

            computeGradientPenalty(interpolatedImages) {
                return tf.tidy(() => {
                    const gradients = tf.grad(x => {
                        const predictions = this.discriminator.predict(x);
                        return tf.mean(predictions);
                    })(interpolatedImages);

                    const gradientNorms = tf.sqrt(tf.sum(tf.square(gradients), [1, 2, 3]));
                    return tf.mean(tf.square(gradientNorms.sub(1)));
                });
            }

             async trainGenerator() {
                return tf.tidy(() => {
                    const noise = tf.randomNormal([this.batchSize, this.latentDim]);
                    
                    const gradients = () => {
                        const fakeImages = this.generator.predict(noise);
                        const fakeOutput = this.discriminator.predict(fakeImages);
                        return tf.mean(fakeOutput).mul(-1);
                    };

                    const {value, grads} = this.gOptimizer.computeGradients(gradients);
                    this.gOptimizer.applyGradients(grads);
                    return value;
                });
            }
             generateImage() {
                return tf.tidy(() => {
                    const noise = tf.randomNormal([1, this.latentDim]);
                    return this.generator.predict(noise);
                });
            }
        }

        // Modified Training Controller
        class TrainingController {
            constructor(wgan, ui) {
                this.wgan = wgan;
                this.ui = ui;
                this.isTraining = false;
                this.numEpochs = 10;
                this.trainImages = null;
                this.systemCheck = new SystemCheck();
                this.setupEventListeners();
            }

            setupEventListeners() {
                 this.ui.elements.trainButton.onclick = () => this.toggleTraining();
                 this.ui.elements.generateButton.onclick = () => this.generateImage();
                document.getElementById('checkSystem').onclick = () => this.checkSystemResources();
            }

             async checkSystemResources() {
                const params = await this.systemCheck.getOptimalParameters();
                this.ui.updateSystemInfo(params);
                
                // Update sliders with recommended values
                document.getElementById('batchSize').value = params.batchSize;
                document.getElementById('epochs').value = params.epochs;
                document.getElementById('latentDim').value = params.latentDim;
                
                // Update displayed values
                document.getElementById('batchSizeValue').textContent = params.batchSize;
                document.getElementById('epochsValue').textContent = params.epochs;
                document.getElementById('latentDimValue').textContent = params.latentDim;
                
                // Show warning if resources are limited
                this.ui.showResourceWarning(params.batchSize < 16);
            }
              async loadMNIST() {
                this.ui.updateStatus('Loading MNIST dataset...');
                
                try {
                    // Load MNIST data using mnist package
                    const mnist = await tf.loadLayersModel('https://storage.googleapis.com/tfjs-models/tfjs/mnist_transfer_cnn_v1/model.json');
                    const [trainImages] = tf.tidy(() => {
                        const d = new Array(60000).fill(0).map(() => 
                            tf.randomUniform([28, 28, 1], -1, 1)
                        );
                       const xs = tf.stack(d) 
                        return [xs];
                    });
                    
                    this.ui.updateStatus('Dataset loaded. Starting training...');

                    this.ui.updateProgress('Processing dataset', 1);
                    await new Promise(resolve => setTimeout(resolve, 500));
                    this.ui.elements.progressContainer.style.display = 'none';
                    
                    return trainImages; // return the images here, not xs
                } catch (error) {
                    this.ui.updateStatus(`Error loading dataset: ${error.message}`);
                    throw error;
                }
            }


            async train() {
                try {
                    if (!this.trainImages) {
                        this.trainImages = await this.loadMNIST();
                    }

                    this.ui.updateStatus('Training started...');
                    const numSamples = 60000; // MNIST has 60k training samples
                    const batchesPerEpoch = Math.floor(numSamples / this.wgan.batchSize);

                    for (let epoch = 0; epoch < this.numEpochs && this.isTraining; epoch++) {
                        const indices = tf.util.createShuffledIndices(numSamples);
                        
                        for (let batch = 0; batch < batchesPerEpoch && this.isTraining; batch++) {
                            const startIdx = batch * this.wgan.batchSize;
                            const batchIndices = indices.slice(startIdx, startIdx + this.wgan.batchSize);
                            
                            const batchImages = tf.tidy(() => {
                                const indicesTensor = tf.tensor1d(batchIndices, 'int32'); // Convert to tensor here
                                return tf.gather(this.trainImages, indicesTensor)
                            });

                            // Train discriminator
                            let dLoss = 0;
                            for (let i = 0; i < 5; i++) {
                                dLoss = await this.wgan.trainDiscriminator(batchImages);
                            }

                            // Train generator
                            const gLoss = await this.wgan.trainGenerator();

                            // Update UI
                            this.ui.updateMetrics(
                                epoch + 1,
                                this.numEpochs,
                                dLoss.dataSync()[0],
                                gLoss.dataSync()[0]
                            );

                            // Generate sample image periodically
                            if (batch % 10 === 0) {
                                const generatedImage = this.wgan.generateImage();
                                 this.ui.displayImage(generatedImage.reshape([28, 28]));
                                 tf.dispose(generatedImage);
                            }
                            
                            tf.dispose([batchImages]);
                            await tf.nextFrame();
                        }
                    }

                    this.ui.updateStatus(this.isTraining ? 'Training completed.' : 'Training stopped.');
                    this.isTraining = false;
                    this.ui.setTrainingState(false);

                } catch (error) {
                    this.ui.updateStatus(`Training error: ${error.message}`);
                    console.error(error);
                    this.isTraining = false;
                    this.ui.setTrainingState(false);
                }
            }

            async toggleTraining() {
                if (!this.isTraining) {
                    this.isTraining = true;
                    this.ui.setTrainingState(true);
                    await this.train();
                } else {
                    this.isTraining = false;
                    this.ui.setTrainingState(false);
                }
            }

            async generateImage() {
                try {
                     const generatedImage = this.wgan.generateImage();
                    this.ui.displayImage(generatedImage.reshape([28, 28]));
                    tf.dispose(generatedImage);
                } catch (error) {
                    this.ui.updateStatus(`Error generating image: ${error.message}`);
                }
            }
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', async () => {
            try {
                const systemCheck = new SystemCheck();
                const params = await systemCheck.getOptimalParameters();
                
                const ui = new UIController();
                const wgan = new WGAN(params);
                const trainer = new TrainingController(wgan, ui);
                
                // Initial system check
                trainer.checkSystemResources();
                
                // Set up parameter change listeners
                ['batchSize', 'epochs', 'latentDim'].forEach(param => {
                    const slider = document.getElementById(param);
                    const valueDisplay = document.getElementById(`${param}Value`);
                    slider.addEventListener('input', () => {
                        valueDisplay.textContent = slider.value;
                        // Update WGAN parameters if needed
                        if (param in wgan) {
                            wgan[param] = parseInt(slider.value);
                        }
                    });
                });

                // Configure TensorFlow.js
                await tf.setBackend('webgl');
                tf.env().set('WEBGL_DELETE_TEXTURE_THRESHOLD', 0);
                // Set up error handling
                 window.addEventListener('error', (event) => {
                    ui.updateStatus(`Error: ${event.message}`);
                });

                // Memory cleanup on page unload
                window.addEventListener('beforeunload', () => {
                    tf.dispose();
                });

            } catch (error) {
                console.error('Initialization error:', error);
                document.getElementById('status').textContent = 
                    `Failed to initialize: ${error.message}`;
            }
        });
    </script>
</body>
</html>